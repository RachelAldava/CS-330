This was my final project of the CS-330 “Computer Graphic and Visualization” course.
In this course we used OpenGL to learn some concepts involving 3d graphics. The readings from this course were from the website https://learnopengl.com/ . 
We were given a starter code which, when executed, would run a program whose environment is similar to a 3d video game. The environment featured two orthogonal square planes on which there were several 3d objects which were shaped, textured, and lit in order to produce the effect of a set table with plates, utensils, grapes, bread, and a wheel of cheese. I would approximate the graphical detail to be similar in quality as was found in Bethesda’s “The elder scrolls: Oblivion”.
As students, we were asked to invent a scene to reproduce, complete with shaped objects, textures, and lighting. I selected an assortment of items on my desk: A notebook, an inkwell, a fountain pen, and a chess piece.
It’s better to show, rather than tell, the results of my efforts: https://youtu.be/vY0mhMj5EsM
In this video, the first thing pictured is an animated chess board. This was a side-project I worked on for fun. Currently, chess games are hard-coded into the chessboard constructor as a series of squares: {white start (e2), white end (e4), black start (e7), black end (e5)}. I hope to expand this functionality into a method which can parse a text file containing standard notation into my series-of-squares format. Chess notation has some oddities which makes it non-trivial to parse, but I do not expect much difficulty.
The next thing the video shows is the set of objects which was the result of my main project. 
The first thing I focused on was simplifying how shapes are created and placed. A description of the OpenGL coordinate system is found here: https://learnopengl.com/Getting-started/Transformations
The bulk of my code built off of the starter code first by generalizing the pre-defined meshes into a single “Shape” class which contained information about scale, position, and rotation of the object along with identifiers for what mesh it would be rendered with. At time of rendering, different objects would receive the appropriate instructions on how to render it.
This let me create an “Object” class which consisted of a vector of Shape pointers in addition to its own set of scale, rotation, and position values. This enabled me to add shapes to the object using relational values. For instance, in the chess board the placement of the chess squares relative to the Object origin would have localized values which ranged from (-.4, .1, -.4), (-.3, .1, -.4) … (4, .1, -.4), (-.3, .1, -.4) … (.4, .1, .4). Then, wherever I placed the chess board, each individual square would have a global scale/rotation/position offset by the local position.
This ability to develop within a local space enabled me to rapidly prototype and iterate new objects without needing to keep track of where they were globally. A side-effect of this was to enable animations to occur by manipulating the Object-level coordinates rather than the individual shapes. This enabled me to move chess pieces easily (and also the entire board, if needed). The individual animations were the work of a single lunch break. It’s the same animation: There is a pre-defined speed, there is a clock value and an object receives a destination coordinate; the rate of x,y, and z change is calculated based off of starting coordinates, destination coordinates, and speed. Midway through the animation, the y rate is reversed into negatives in order for the piece to reach the destination on time. Once that animation was defined, the only other step was to introduce logic to determine which pieces would move at which times.
The various Shape and Object classes were developed over time throughout the course, slowly getting improved. There are a few features I would like to add, such as a more flexible way of defining sub-objects and reducing the CPU load spent on rendering static objects, but I sincerely believe that the Shape and Object pair could form the basis for constructing a fairly detailed environment for a videogame.
As for the visual elements, I mostly tried to select high resolution textures, then recolor them in third party programs. Then, when lighting them, I would consult the color wheel in order to determine which RGB values to modify in order to shift the reflected colors to desired values.
Currently, I am not considering a career in computer graphics or video game design. This course has given me a solid foundation to build off of, should I ever decide to change my goals. I feel that most of my work in this course was not specific to 3d-graphics, but rather, experience in extensively modifying an existing codebase by introducing new features. I also got a lot of quality c++ practice in. I worked extensively with pointers, various data structures, vectors, and matrices. I encountered many issues, some of which were caused by c++ idiosyncrasies and some which were purely self-inflicted. I overcame these obstacles and taught myself a lot along the way. This has been my biggest time investment on a single project so far, and I am very proud of the results.
